1)State
2)Strict mode
3)Updating the array or object
4)Return
5)Event Handling


1) State is just a way to store data inside a component ‚Äî like a variable that can change and automatically update the UI when it does.

`
const [count, setCount] = useState(0);


 `count` ‚Üí your current value (like a variable)
 `setCount` ‚Üí a function to change the value
 `useState(0)` ‚Üí sets the initial value


 üîÅ Why do we use State?

Imagine a counter app:


<button onClick={() => setCount(count + 1)}>Click Me</button>


Every time you click, React:

1. Changes the value
2. Re-renders the UI with the **new value**

So:
üñ±Ô∏è You click ‚Üí üß† State changes ‚Üí üñºÔ∏è UI updates automatically



 ‚úÖ When to use State (and which one to use)

| Situation                            | Should I use `useState`? | Example value stored                |
| ------------------------------------ | ------------------------ | ----------------------------------- |
| User input (text, email, etc.)       | ‚úÖ Yes                    | `name`, `email`, `password`         |
| Button clicks / toggles              | ‚úÖ Yes                    | `isVisible`, `isDarkMode`, `count`  |
| Conditional display (like error msg) | ‚úÖ Yes                    | `errorShown`, `formSubmitted`       |
| Data from backend (once fetched)     | ‚úÖ Yes (initially empty)  | `products`, `userProfile`, `posts`  |
| Fixed data that never changes        | ‚ùå No (use `const`)       | API key, heading text, static links |



üí° Remember:

 `useState` is for changing data
 When state changes, the component re-renders
You can have **many `useState` in one component



 üß™ Real Example: Login Form


const [email, setEmail] = useState('');
const [password, setPassword] = useState('');
const [submitted, setSubmitted] = useState(false);
const [error, setError] = useState('');


‚ö†Ô∏è Don't use state when:

 The data will **never change**
 It's calculated on the fly from props

2)Strict mode

 -->build in component

there are two ways to use Strict mode

  1)in index.jsx
     
    <React.StrictMode>
    <App />
   </React.StrictMode>

 -->we just need to import React from'react';


   2)

    <StrictMode>
    <App />
    </StrictMode>

    -->but we need to import {StrictMode} from 'react';
       and also need to use wrapping component like 
       <StrictMode>
       </StrictMode>

strictmode is used to excute every component function twice

All of these checks are development-only and do not impact the production build.


3) creating new array for old array OR Updating the array or object

function(prev) {
  return [...prev, newItem];
}

example:

   function addTodo(task) {
  setTodos((prev) => [
    ...prev,
    { id: Date.now(), task, completed: false }
  ]);
}

4) Return

   When you use return inside a function, it immediately stops the function from running further.

   if (!input.trim()) return;

5)event handling

In **React**, when you use `event.target.value`, you're capturing **what the user typed or selected** ‚Äî and you can:

Store it -> in a state variable (`useState`)
Print it ->to the console (`console.log()`)
Send it ->to a server (`fetch` or `axios`)
Use it ->to update UI instantly

code:

<input
  type="text"
  onChange={(event) => console.log(event.target.value)}
/>


output:
A
As
Asw
Aswi
Aswin
```

Because every keystroke triggers `onChange`, and `event.target.value` gives you the latest value typed in the input box.

import { useState } from 'react';

function MyForm() {
  const [name, setName] = useState('');

  function handleChange(event) {
    console.log(event.target.value); // shows what user typed
    setName(event.target.value);     // stores it in state
  }

  return (
    <div>
      <input type="text" onChange={handleChange} />
      <p>Hello, {name}</p>
    </div>
  );
}

output:

 You type: `Aswin`
 It logs to the console.
 `name` gets updated.
 It shows: `Hello, Aswin`



| Concept                | Meaning                                   |
| ---------------------- | ----------------------------------------- |
| `event`                | The full event info from the browser      |
| `event.target`         | The exact input field that was interacted |
| `event.target.value`   | What the user typed                       |
| Store it in `useState` | To keep the data and use it later         |




